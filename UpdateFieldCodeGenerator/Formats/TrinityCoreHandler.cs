using System.Collections;
using System.Reflection;
using static UpdateFieldCodeGenerator.UpdateField;

namespace UpdateFieldCodeGenerator.Formats
{
    public class TrinityCoreHandler : UpdateFieldHandlerBase
    {
        private readonly Type _updateFieldBaseType = CppTypes.CreateType("UpdateFieldBase", "T");
        private readonly Type _updateFieldType = CppTypes.CreateType("UpdateField", "T", "BlockBit", "Bit");
        private readonly Type _arrayUpdateFieldBaseType = CppTypes.CreateType("UpdateFieldArrayBase", "T", "Size");
        private readonly Type _arrayUpdateFieldType = CppTypes.CreateType("UpdateFieldArray", "T", "Size", "PrimaryBit", "FirstElementBit");
        private readonly Type _dynamicUpdateFieldBaseType = CppTypes.CreateType("DynamicUpdateFieldBase", "T");
        private readonly Type _dynamicUpdateFieldType = CppTypes.CreateType("DynamicUpdateField", "T", "BlockBit", "Bit");
        private readonly Type _optionalUpdateFieldBaseType = CppTypes.CreateType("OptionalUpdateFieldBase", "T");
        private readonly Type _optionalUpdateFieldType = CppTypes.CreateType("OptionalUpdateField", "T", "BlockBit", "Bit");

        private UpdateFieldFlag _allUsedFlags;
        private readonly IDictionary<int, ISet<UpdateFieldFlag>> _flagByUpdateBit = new Dictionary<int, ISet<UpdateFieldFlag>>();

        private readonly string _changesMaskName = "_changesMask";
        private string _owningObjectType;
        private readonly IList<Action> _delayedHeaderWrites = new List<Action>();
        private readonly IList<string> _changesMaskClears = new List<string>();
        private readonly IList<string> _equalityComparisonFields = new List<string>();
        private readonly IList<string> _viewerDependentVariables = new List<string>();

        public TrinityCoreHandler() : base(new StreamWriter("UpdateFields.cpp"), new StreamWriter("UpdateFields.h"))
        {
        }

        public override void BeforeStructures()
        {
            var forwardDeclareTypes = Enum.GetValues(typeof(ObjectType))
                .Cast<ObjectType>()
                .Select(objectType => GetClassForObjectType(objectType))
                .Distinct()
                .Concat(Enumerable.Repeat("ByteBuffer", 1))
                .OrderBy(o => o);

            WriteLicense(_header);
            _header.WriteLine("#ifndef UpdateFields_h__");
            _header.WriteLine("#define UpdateFields_h__");
            _header.WriteLine();
            _header.WriteLine("#include \"EnumFlag.h\"");
            _header.WriteLine("#include \"ItemPacketsCommon.h\"");
            _header.WriteLine("#include \"MythicPlusPacketsCommon.h\"");
            _header.WriteLine("#include \"ObjectGuid.h\"");
            _header.WriteLine("#include \"PerksProgramPacketsCommon.h\"");
            _header.WriteLine("#include \"Position.h\"");
            _header.WriteLine("#include \"QuaternionData.h\"");
            _header.WriteLine("#include \"UpdateField.h\"");
            _header.WriteLine("#include \"UpdateMask.h\"");
            _header.WriteLine();
            WriteAutogeneratedDisclaimer(_header);
            foreach (var fwd in forwardDeclareTypes)
                _header.WriteLine($"class {fwd};");
            _header.WriteLine();
            _header.WriteLine("namespace UF");
            _header.WriteLine("{");

            WriteLicense(_source);
            _source.WriteLine("#include \"UpdateFields.h\"");
            _source.WriteLine("#include \"AreaTrigger.h\"");
            _source.WriteLine("#include \"ByteBuffer.h\"");
            _source.WriteLine("#include \"Corpse.h\"");
            _source.WriteLine("#include \"DynamicObject.h\"");
            _source.WriteLine("#include \"PacketOperators.h\"");
            _source.WriteLine("#include \"Player.h\"");
            _source.WriteLine("#include \"ViewerDependentValues.h\"");
            _source.WriteLine();
            WriteAutogeneratedDisclaimer(_source);
            _source.WriteLine("#if TRINITY_COMPILER == TRINITY_COMPILER_GNU");
            _source.WriteLine("#pragma GCC diagnostic push");
            _source.WriteLine("#pragma GCC diagnostic ignored \"-Wunused-parameter\"");
            _source.WriteLine("#else");
            _source.WriteLine("#pragma warning(push)");
            _source.WriteLine("#pragma warning(disable: 4100)");
            _source.WriteLine("#endif");
            _source.WriteLine();
            _source.WriteLine("namespace UF");
            _source.WriteLine("{");
        }

        public override void AfterStructures()
        {
            _header.WriteLine("}");
            _header.WriteLine();
            _header.WriteLine("#endif // UpdateFields_h__");

            _source.WriteLine("}");
            _source.WriteLine();
            _source.WriteLine("#if TRINITY_COMPILER == TRINITY_COMPILER_GNU");
            _source.WriteLine("#pragma GCC diagnostic pop");
            _source.WriteLine("#else");
            _source.WriteLine("#pragma warning(pop)");
            _source.WriteLine("#endif");
        }

        public override void OnStructureBegin(Type structureType, ObjectType objectType, bool create, bool writeUpdateMasks)
        {
            base.OnStructureBegin(structureType, objectType, create, writeUpdateMasks);
            _allUsedFlags = UpdateFieldFlag.None;
            _flagByUpdateBit.Clear();
            _flagByUpdateBit[0] = new SortedSet<UpdateFieldFlag>() { UpdateFieldFlag.None };
            _owningObjectType = GetClassForObjectType(objectType);
            _delayedHeaderWrites.Clear();
            _changesMaskClears.Clear();
            _equalityComparisonFields.Clear();
            _viewerDependentVariables.Clear();
        }

        public override void OnStructureEnd(bool needsFlush, bool forceMaskMask)
        {
            var structureName = RenameType(_structureType);

            ++_bitCounter;
            if (!_create)
            {
                _header.Write($"struct {RenameType(_structureType)} : public IsUpdateFieldStructureTag");
                if (_writeUpdateMasks)
                    _header.Write($", public HasChangesMask<{_bitCounter}>");
                _header.WriteLine();
                _header.WriteLine("{");

                foreach (var headerWrite in _delayedHeaderWrites)
                    headerWrite();

                _header.WriteLine();
                if (_isRoot)
                    _header.WriteLine($"    void WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, {_owningObjectType} const* owner, Player const* receiver) const;");
                else
                    _header.WriteLine($"    void WriteCreate(ByteBuffer& data, {_owningObjectType} const* owner, Player const* receiver) const;");

                if (_isRoot)
                    _header.WriteLine($"    void WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, {_owningObjectType} const* owner, Player const* receiver) const;");
                else
                    _header.WriteLine($"    void WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, {_owningObjectType} const* owner, Player const* receiver) const;");

                if (_writeUpdateMasks)
                {
                    if (_isRoot)
                        _header.WriteLine($"    void WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, {_owningObjectType} const* owner, Player const* receiver) const;");

                    if (_allUsedFlags != UpdateFieldFlag.None)
                    {
                        _header.WriteLine($"    static void AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags);");
                        _header.WriteLine($"    static void FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags);");
                    }

                    _header.WriteLine("    void ClearChangesMask();");
                }
                else
                {
                    _header.WriteLine($"    bool operator==({structureName} const& right) const;");
                    _header.WriteLine($"    bool operator!=({structureName} const& right) const {{ return !(*this == right); }}");
                }

                foreach (var dynamicChangesMaskType in _dynamicChangesMaskTypes)
                    _header.WriteLine($"    bool Is{RenameType(dynamicChangesMaskType)}ChangesMaskSkipped() const {{ return false; }} // bandwidth savings aren't worth the cpu time");

                _header.WriteLine("};");
                _header.WriteLine();
                _header.Flush();
            }

            if (!_create && _writeUpdateMasks)
            {
                var bitMaskByFlag = new Dictionary<UpdateFieldFlag, BitArray>();
                if (_allUsedFlags != UpdateFieldFlag.None)
                {
                    for (var i = 0; i < _bitCounter; ++i)
                    {
                        if (_flagByUpdateBit.TryGetValue(i, out var flags))
                        {
                            foreach (var flag in flags)
                                bitMaskByFlag.ComputeIfAbsent(flag, k => new BitArray(_bitCounter)).Set(i, true);
                        }
                        else
                            bitMaskByFlag.ComputeIfAbsent(UpdateFieldFlag.None, k => new BitArray(_bitCounter)).Set(i, true);
                    }

                    var noneFlags = new int[(_bitCounter + 31) / 32];
                    bitMaskByFlag[UpdateFieldFlag.None].CopyTo(noneFlags, 0);
                }

                if (_allUsedFlags != UpdateFieldFlag.None)
                {
                    _source.WriteLine($"static constexpr void {structureName}AppendAllowedFieldsMaskForFlag({structureName}::Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)");
                    _source.WriteLine("{");
                    for (var j = 0; j < 8; ++j)
                    {
                        if ((_allUsedFlags & (UpdateFieldFlag)(1 << j)) != UpdateFieldFlag.None)
                        {
                            var flagArray = new int[(_bitCounter + 31) / 32];
                            bitMaskByFlag[(UpdateFieldFlag)(1 << j)].CopyTo(flagArray, 0);
                            _source.WriteLine($"    if (fieldVisibilityFlags.HasFlag(UpdateFieldFlag::{(UpdateFieldFlag)(1 << j)}))");
                            _source.WriteLine($"        allowedMaskForTarget |= std::array<uint32, {flagArray.Length}>{{ {string.Join(", ", flagArray.Select(v => "0x" + v.ToString("X8") + "u"))} }};");
                        }
                    }
                    _source.WriteLine("}");
                    _source.WriteLine();

                    _source.WriteLine($"void {structureName}::AppendAllowedFieldsMaskForFlag(Mask& allowedMaskForTarget, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)");
                    _source.WriteLine("{");
                    _source.WriteLine($"    {structureName}AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);");
                    _source.WriteLine("}");
                    _source.WriteLine();

                    var noneFlags = new int[(_bitCounter + 31) / 32];
                    bitMaskByFlag[UpdateFieldFlag.None].CopyTo(noneFlags, 0);

                    _source.WriteLine($"void {structureName}::FilterDisallowedFieldsMaskForFlag(Mask& changesMask, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags)");
                    _source.WriteLine("{");
                    _source.WriteLine($"    Mask allowedMaskForTarget({{ {string.Join(", ", noneFlags.Select(v => "0x" + v.ToString("X8") + "u"))} }});");
                    _source.WriteLine($"    {structureName}AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);");
                    _source.WriteLine($"    changesMask &= allowedMaskForTarget;");
                    _source.WriteLine("}");
                    _source.WriteLine();
                }

                _source.WriteLine(_isRoot
                    ? $"void {structureName}::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, {_owningObjectType} const* owner, Player const* receiver) const"
                    : $"void {structureName}::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, {_owningObjectType} const* owner, Player const* receiver) const");

                _source.WriteLine("{");

                if (_allUsedFlags != UpdateFieldFlag.None)
                {
                    var noneFlags = new int[(_bitCounter + 31) / 32];
                    bitMaskByFlag[UpdateFieldFlag.None].CopyTo(noneFlags, 0);

                    _source.WriteLine($"    Mask allowedMaskForTarget({{ {string.Join(", ", noneFlags.Select(v => "0x" + v.ToString("X8") + "u"))} }});");
                    _source.WriteLine($"    {structureName}AppendAllowedFieldsMaskForFlag(allowedMaskForTarget, fieldVisibilityFlags);");
                    _source.WriteLine($"    WriteUpdate(data, {_changesMaskName} & allowedMaskForTarget, false, owner, receiver);");
                }
                else if (_isRoot)
                    _source.WriteLine($"    WriteUpdate(data, {_changesMaskName}, false, owner, receiver);");

                if (_isRoot)
                {
                    _source.WriteLine("}");
                    _source.WriteLine();
                }

                if (_isRoot)
                {
                    _source.WriteLine($"void {structureName}::WriteUpdate(ByteBuffer& data, Mask const& changesMask, bool ignoreNestedChangesMask, {_owningObjectType} const* owner, Player const* receiver) const");
                    _source.WriteLine("{");
                }
                else
                {
                    _source.WriteLine($"    Mask changesMask = _changesMask;");
                    _source.WriteLine( "    if (ignoreChangesMask)");
                    _source.WriteLine( "        changesMask.SetAll();");
                    _source.WriteLine();
                }

                var maskBlocks = (_bitCounter + 31) / 32;
                if (forceMaskMask)
                {
                    if (maskBlocks > 32)
                    {
                        _source.WriteLine($"    for (uint32 i = 0; i < {maskBlocks / 32}; ++i)");
                        _source.WriteLine($"        data << uint32(changesMask.GetBlocksMask(i));");
                        if ((maskBlocks % 32) != 0)
                            _source.WriteLine($"    data.WriteBits(changesMask.GetBlocksMask({maskBlocks / 32}), {maskBlocks % 32});");
                    }
                    else
                        _source.WriteLine($"    data.WriteBits(changesMask.GetBlocksMask(0), {maskBlocks});");

                    if (maskBlocks > 1)
                    {
                        _source.WriteLine($"    for (uint32 i = 0; i < {maskBlocks}; ++i)");
                        _source.WriteLine("        if (changesMask.GetBlock(i))");
                        _source.WriteLine("            data.WriteBits(changesMask.GetBlock(i), 32);");
                    }
                    else
                    {
                        _source.WriteLine("    if (changesMask.GetBlock(0))");
                        _source.WriteLine("        data.WriteBits(changesMask.GetBlock(0), 32);");
                    }
                }
                else
                {
                    var blockIndex = 0;
                    var bitCounter = _bitCounter;
                    while (bitCounter > 32)
                    {
                        _source.WriteLine($"    data << uint32(changesMask.GetBlock({blockIndex}));");
                        ++blockIndex;
                        bitCounter -= 32;
                    }

                    if (bitCounter > 0)
                        _source.WriteLine($"    data.WriteBits(changesMask.GetBlock({blockIndex}), {bitCounter});");
                }

                _source.WriteLine();
            }
            else if (!_create)
            {
                _source.WriteLine(_isRoot
                    ? $"void {structureName}::WriteUpdate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, {_owningObjectType} const* owner, Player const* receiver) const"
                    : $"void {structureName}::WriteUpdate(ByteBuffer& data, bool ignoreChangesMask, {_owningObjectType} const* owner, Player const* receiver) const");

                _source.WriteLine("{");
            }
            else
            {
                _source.WriteLine(_isRoot
                    ? $"void {structureName}::WriteCreate(ByteBuffer& data, EnumFlag<UpdateFieldFlag> fieldVisibilityFlags, {_owningObjectType} const* owner, Player const* receiver) const"
                    : $"void {structureName}::WriteCreate(ByteBuffer& data, {_owningObjectType} const* owner, Player const* receiver) const");

                _source.WriteLine("{");
            }

            PostProcessFieldWrites();

            if (_viewerDependentVariables.Count > 0)
            {
                foreach (var viewerDependentVariable in _viewerDependentVariables)
                    _source.WriteLine($"    {viewerDependentVariable}");

                _source.WriteLine();
            }

            if (!_create)
            {
                foreach (var dynamicChangesMaskType in _dynamicChangesMaskTypes)
                {
                    var typeName = RenameType(dynamicChangesMaskType);
                    _source.WriteLine($"    bool no{typeName}ChangesMask = data.WriteBit(Is{typeName}ChangesMaskSkipped());");
                }
            }

            List<FlowControlBlock> previousFlowControl = null;
            foreach (var (_, _, Write) in _fieldWrites)
                previousFlowControl = Write(previousFlowControl);

            if (needsFlush)
                _source.WriteLine($"{GetIndent()}data.FlushBits();");

            _source.WriteLine("}");
            _source.WriteLine();

            if (!_create)
            {
                if (_writeUpdateMasks)
                {
                    _source.WriteLine($"void {structureName}::ClearChangesMask()");
                    _source.WriteLine("{");
                    foreach (var clear in _changesMaskClears)
                        _source.WriteLine(clear);
                    _source.WriteLine($"    {_changesMaskName}.ResetAll();");
                    _source.WriteLine("}");
                    _source.WriteLine();
                }
                else
                {
                    _source.WriteLine($"bool {structureName}::operator==({structureName} const& right) const");
                    _source.WriteLine("{");
                    _source.WriteLine($"    return {string.Join(Environment.NewLine + "        && ", _equalityComparisonFields)};");
                    _source.WriteLine("}");
                    _source.WriteLine();
                }
            }

            _source.Flush();
        }

        public override IReadOnlyList<FlowControlBlock> OnField(string name, UpdateField updateField, IReadOnlyList<FlowControlBlock> previousControlFlow)
        {
            _allUsedFlags |= updateField.Flag;

            name = RenameField(name);

            var flowControl = new List<FlowControlBlock>();
            if (_create && updateField.Flag != UpdateFieldFlag.None)
                flowControl.Add(new FlowControlBlock { Statement = $"if (fieldVisibilityFlags.HasFlag({updateField.Flag.ToFlagsExpression(" | ", "UpdateFieldFlag::")}))" });

            var type = updateField.Type;
            var access = _writeUpdateMasks ? "->" : ".";
            var nameUsedToWrite = updateField.SizeForField != null ? string.Format(name, access) : name;
            var arrayLoopBlockIndex = -1;
            var indexLetter = 'i';
            var allIndexes = "";
            if (updateField.SizeForField != null && typeof(VariantUpdateField).IsAssignableFrom(((UpdateField)updateField.SizeForField.GetValue(null)).Type))
            {
                nameUsedToWrite = $"{RenameField(updateField.SizeForField.Name)}.Get<{TypeHandler.GetFriendlyName(PrepareFieldType(type))}>()";
            }
            if (type.IsArray)
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 {indexLetter} = 0; {indexLetter} < {updateField.Size}; ++{indexLetter})" });

                if (updateField.SizeForField != null)
                    nameUsedToWrite = string.Format(name, $"[{indexLetter}].");
                else
                    nameUsedToWrite += $"[{indexLetter}]";

                access = ".";
                type = type.GetElementType();
                arrayLoopBlockIndex = flowControl.Count;
                allIndexes += ", " + indexLetter;
                ++indexLetter;
            }
            if (typeof(DynamicUpdateField).IsAssignableFrom(type))
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 {indexLetter} = 0; {indexLetter} < {nameUsedToWrite}.size(); ++{indexLetter})" });
                if (!_create)
                    flowControl.Add(new FlowControlBlock { Statement = $"if ({nameUsedToWrite}.HasChanged({indexLetter}) || {(_isRoot ? "ignoreNestedChangesMask" : "ignoreChangesMask")})" });

                nameUsedToWrite += $"[{indexLetter}]";
                access = ".";
                type = type.GenericTypeArguments[0];
                allIndexes += ", " + indexLetter;
                ++indexLetter;
            }
            if (typeof(BlzOptionalField).IsAssignableFrom(type))
            {
                flowControl.Add(new FlowControlBlock { Statement = $"if ({name}.has_value())" });
                type = type.GenericTypeArguments[0];
            }

            if ((updateField.CustomFlag & CustomUpdateFieldFlag.ViewerDependent) != CustomUpdateFieldFlag.None)
            {
                if (typeof(BlzVectorField).IsAssignableFrom(type))
                    nameUsedToWrite = char.ToLower(nameUsedToWrite[0]) + nameUsedToWrite[1..];
                else if (updateField.SizeForField != null)
                {
                    nameUsedToWrite = char.ToLower(nameUsedToWrite[0]) + nameUsedToWrite[1..];
                    var origName = RenameField(updateField.SizeForField.Name);
                    var variableName = $"{char.ToLower(origName[0])}{origName[1..]}";
                    _viewerDependentVariables.Add($"ViewerDependentValue<{origName}Tag>::value_type {variableName} = {{}};");
                    _fieldWrites.Add((name + "_var_init", false, (pcf) =>
                    {
                        WriteControlBlocks(_source, flowControl, pcf);
                        _source.Write(GetIndent());
                        _source.WriteLine($"{variableName} = ViewerDependentValue<{origName}Tag>::GetValue(this{allIndexes}, owner, receiver);");
                        _indent = 1;
                        return flowControl;
                    }));
                }
                else
                    nameUsedToWrite = $"ViewerDependentValue<{name}Tag>::GetValue(this{allIndexes}, owner, receiver)";
            }

            if (typeof(BlzVectorField).IsAssignableFrom(type))
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 {indexLetter} = 0; {indexLetter} < {nameUsedToWrite}{access}size(); ++{indexLetter})" });
                if (_writeUpdateMasks)
                    nameUsedToWrite = $"(*{nameUsedToWrite})";

                nameUsedToWrite += $"[{indexLetter}]";
                access = ".";
                type = type.GenericTypeArguments[0];
                ++indexLetter;
            }
            if (!_create && _writeUpdateMasks)
            {
                GenerateBitIndexConditions(updateField, name, flowControl, previousControlFlow, arrayLoopBlockIndex);
                if (name.EndsWith("has_value()"))
                {
                    if (_blockGroupSize > 0)
                        flowControl.RemoveAt(1); // bit generated but not checked for has_value
                    else
                        flowControl.RemoveAt(0);
                }
            }

            flowControl.AddRange(updateField.Conditions
                .GroupBy(cond => cond.OrGroup)
                .Select(conditionsGroup => conditionsGroup
                    .Select(condition => $"{RenameField(condition.FieldToCompare.Name)} {condition.OperatorAndConstant}"))
                .Select(conditions => new FlowControlBlock { Statement = $"if ({string.Join(" || ", conditions)})" }));

            if (updateField.CustomFlag.HasFlag(CustomUpdateFieldFlag.HasDynamicChangesMask))
                RegisterDynamicChangesMaskFieldType(type);

            if (!typeof(VariantUpdateField).IsAssignableFrom(updateField.Type))
            {
                _fieldWrites.Add((name, false, (pcf) =>
                {
                    WriteControlBlocks(_source, flowControl, pcf);
                    WriteField(nameUsedToWrite, access, type, updateField.BitSize);
                    _indent = 1;
                    return flowControl;
                }
                ));
            }

            if (!_create && updateField.SizeForField == null)
            {
                _delayedHeaderWrites.Add(() =>
                {
                    WriteFieldDeclaration(name, updateField, updateField.UpdateBitGroup);
                });
                if (_writeUpdateMasks)
                    _changesMaskClears.Add($"    Base::ClearChangesMask({name});");
                else
                    _equalityComparisonFields.Add($"{name} == right.{name}");
            }

            return flowControl;
        }

        public override IReadOnlyList<FlowControlBlock> OnDynamicFieldSizeCreate(string name, UpdateField updateField, IReadOnlyList<FlowControlBlock> previousControlFlow)
        {
            name = RenameField(name);

            var flowControl = new List<FlowControlBlock>();
            if (_create && updateField.Flag != UpdateFieldFlag.None)
                flowControl.Add(new FlowControlBlock { Statement = $"if (fieldVisibilityFlags.HasFlag({updateField.Flag.ToFlagsExpression(" | ", "UpdateFieldFlag::")}))" });

            var nameUsedToWrite = name;
            if (updateField.Type.IsArray)
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 i = 0; i < {updateField.Size}; ++i)" });
                nameUsedToWrite += "[i]";
            }

            _fieldWrites.Add((name, true, (pcf) =>
            {
                WriteControlBlocks(_source, flowControl, pcf);
                if (updateField.BitSize > 0)
                    _source.WriteLine($"{GetIndent()}data.WriteBits({nameUsedToWrite}.size(), {updateField.BitSize});");
                else
                    _source.WriteLine($"{GetIndent()}data << uint32({nameUsedToWrite}.size());");
                _indent = 1;
                return flowControl;
            }));
            return flowControl;
        }

        public override IReadOnlyList<FlowControlBlock> OnDynamicFieldSizeUpdate(string name, UpdateField updateField, IReadOnlyList<FlowControlBlock> previousControlFlow)
        {
            name = RenameField(name);

            var flowControl = new List<FlowControlBlock>();
            if (_create && updateField.Flag != UpdateFieldFlag.None)
                flowControl.Add(new FlowControlBlock { Statement = $"if (fieldVisibilityFlags.HasFlag({updateField.Flag.ToFlagsExpression(" | ", "UpdateFieldFlag::")}))" });

            var nameUsedToWrite = name;
            var arrayLoopBlockIndex = -1;
            if (updateField.Type.IsArray)
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 i = 0; i < {updateField.Size}; ++i)" });
                nameUsedToWrite += "[i]";
                arrayLoopBlockIndex = flowControl.Count;
            }

            if (_writeUpdateMasks)
                GenerateBitIndexConditions(updateField, name, flowControl, previousControlFlow, arrayLoopBlockIndex);

            _fieldWrites.Add((name, true, (pcf) =>
            {
                WriteControlBlocks(_source, flowControl, pcf);
                var bitCountArgument = updateField.BitSize > 0 ? ", " + updateField.BitSize : "";
                _source.WriteLine($"{GetIndent()}if (!{(_isRoot ? "ignoreNestedChangesMask" : "ignoreChangesMask")})");
                _source.WriteLine($"{GetIndent()}    {nameUsedToWrite}.WriteUpdateMask(data{bitCountArgument});");
                _source.WriteLine($"{GetIndent()}else");
                _source.WriteLine($"{GetIndent()}    WriteCompleteDynamicFieldUpdateMask({nameUsedToWrite}.size(), data{bitCountArgument});");
                _indent = 1;
                return flowControl;
            }));
            return flowControl;
        }

        public override IReadOnlyList<FlowControlBlock> OnOptionalFieldInitCreate(string name, UpdateField updateField, IReadOnlyList<FlowControlBlock> previousControlFlow)
        {
            name = RenameField(name);

            var flowControl = new List<FlowControlBlock>();
            if (_create && updateField.Flag != UpdateFieldFlag.None)
                flowControl.Add(new FlowControlBlock { Statement = $"if (fieldVisibilityFlags.HasFlag({updateField.Flag.ToFlagsExpression(" | ", "UpdateFieldFlag::")}))" });

            var nameUsedToWrite = name;
            if (updateField.Type.IsArray)
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 i = 0; i < {updateField.Size}; ++i)" });
                nameUsedToWrite += "[i]";
            }

            _fieldWrites.Add((name, true, (pcf) =>
            {
                WriteControlBlocks(_source, flowControl, pcf);
                _source.WriteLine($"{GetIndent()}data.WriteBit({nameUsedToWrite}.has_value());");
                _indent = 1;
                return flowControl;
            }
            ));
            return flowControl;
        }

        public override IReadOnlyList<FlowControlBlock> OnOptionalFieldInitUpdate(string name, UpdateField updateField, IReadOnlyList<FlowControlBlock> previousControlFlow)
        {
            name = RenameField(name);

            var flowControl = new List<FlowControlBlock>();

            var nameUsedToWrite = name;
            var arrayLoopBlockIndex = -1;
            if (updateField.Type.IsArray)
            {
                flowControl.Add(new FlowControlBlock { Statement = $"for (uint32 i = 0; i < {updateField.Size}; ++i)" });
                nameUsedToWrite += "[i]";
                arrayLoopBlockIndex = flowControl.Count;
            }

            if (_writeUpdateMasks)
            {
                GenerateBitIndexConditions(updateField, name, flowControl, previousControlFlow, arrayLoopBlockIndex);
                flowControl.RemoveAt(1); // bit generated but not checked for has_value
            }

            _fieldWrites.Add((name, true, (pcf) =>
            {
                WriteControlBlocks(_source, flowControl, pcf);
                _source.WriteLine($"{GetIndent()}data.WriteBit({nameUsedToWrite}.has_value());");
                _indent = 1;
                return flowControl;
            }
            ));
            return flowControl;
        }

        private void GenerateBitIndexConditions(UpdateField updateField, string name, List<FlowControlBlock> flowControl, IReadOnlyList<FlowControlBlock> previousControlFlow, int arrayLoopBlockIndex)
        {
            var newField = false;
            var nameForIndex = updateField.UpdateBitGroup != null
                ? RenameField(updateField.UpdateBitGroup)
                : updateField.SizeForField != null ? RenameField(updateField.SizeForField.Name) : name;
            if (!_fieldBitIndex.TryGetValue(nameForIndex, out var bitIndex))
            {
                bitIndex = new List<int>();
                if (flowControl.Count == 0 || !FlowControlBlock.AreChainsAlmostEqual(previousControlFlow, flowControl)
                    || updateField.CustomFlag.HasFlag(CustomUpdateFieldFlag.ForceNewBlockBit))
                {
                    if (!updateField.Type.IsArray)
                    {
                        ++_nonArrayBitCounter;
                        if (_nonArrayBitCounter == _blockGroupSize)
                        {
                            _blockGroupBit = ++_bitCounter;
                            _nonArrayBitCounter = 1;
                        }
                    }

                    bitIndex.Add(++_bitCounter);

                    if (!updateField.Type.IsArray && _blockGroupSize > 0)
                        bitIndex.Add(_blockGroupBit);
                }
                else
                {
                    if (_previousFieldCounters == null || _previousFieldCounters.Count == 1)
                        throw new Exception("Expected previous field to have been an array");

                    bitIndex.Add(_previousFieldCounters[0]);
                }

                _fieldBitIndex[nameForIndex] = bitIndex;
                newField = true;
            }

            if (_flagByUpdateBit.ContainsKey(bitIndex[0]))
                _flagByUpdateBit[bitIndex[0]].UnionWith(updateField.Flag.ToFlagSet());
            else
                _flagByUpdateBit[bitIndex[0]] = new SortedSet<UpdateFieldFlag>(updateField.Flag.ToFlagSet());

            if (updateField.Type.IsArray)
            {
                flowControl.Insert(0, new FlowControlBlock { Statement = $"if (changesMask[{bitIndex[0]}])" });
                var bitsToGenerate = updateField.Size;
                var conditionIncrement = " + i";
                if (typeof(DynamicUpdateField).IsAssignableFrom(updateField.Type.GetElementType()))
                {
                    bitsToGenerate = 1;
                    conditionIncrement = string.Empty;
                }
                if (updateField.CustomFlag.HasFlag(CustomUpdateFieldFlag.NoArrayElementBits))
                    bitsToGenerate = 0;

                if (newField)
                {
                    bitIndex.AddRange(Enumerable.Range(_bitCounter + 1, bitsToGenerate));
                    _bitCounter += bitsToGenerate;
                }
                if (bitsToGenerate > 0)
                {
                    flowControl.Insert(arrayLoopBlockIndex + 1, new FlowControlBlock { Statement = $"if (changesMask[{bitIndex[1]}{conditionIncrement}])" });
                    for (var i = 0; i < bitsToGenerate; ++i)
                        _flagByUpdateBit[bitIndex[1] + i] = new SortedSet<UpdateFieldFlag>(updateField.Flag.ToFlagSet());
                }
            }
            else
            {
                if (_blockGroupSize > 0)
                {
                    flowControl.Insert(0, new FlowControlBlock { Statement = $"if (changesMask[{bitIndex[1]}])" });
                    flowControl.Insert(1, new FlowControlBlock { Statement = $"if (changesMask[{bitIndex[0]}])" });
                }
                else
                    flowControl.Insert(0, new FlowControlBlock { Statement = $"if (changesMask[{bitIndex[0]}])" });
            }

            _previousFieldCounters = bitIndex;
        }

        private void WriteField(string name, string access, Type type, int bitSize)
        {
            _source.Write(GetIndent());
            if (name.EndsWith("size()"))
            {
                if (type == typeof(DynamicString))
                    name += " + 1";

                if (_create || !_isRoot)
                {
                    var sizeWriteExpression = bitSize > 0 ? $".WriteBits({name}, {bitSize})" : $" << uint32({name})";
                    _source.WriteLine($"data{sizeWriteExpression};");
                }
                else
                    _source.WriteLine($"data.WriteBits({name}, {(bitSize > 0 ? bitSize : 32)});");
                return;
            }

            switch (Type.GetTypeCode(type))
            {
                case TypeCode.Object:
                    if (type == typeof(WowGuid) || type == typeof(Vector2) || type == typeof(Vector3) || type == typeof(DungeonScoreSummary)
                        || type == typeof(DungeonScoreData) || type == typeof(ItemBonusKey) || type == typeof(ItemInstance) || type == typeof(ItemEnchantData)
                        || type == typeof(ItemGemData) || type == typeof(PerksVendorItem))
                    {
                        if (name.Contains('[') || !_writeUpdateMasks)
                            _source.WriteLine($"data << {name};");
                        else
                            _source.WriteLine($"data << *{name};");
                    }
                    else if (type == typeof(Bits))
                        _source.WriteLine($"data.WriteBits({name}, {bitSize});");
                    else if (type == typeof(Quaternion))
                    {
                        _source.WriteLine($"data << float({name}{access}x);");
                        _source.WriteLine($"{GetIndent()}data << float({name}{access}y);");
                        _source.WriteLine($"{GetIndent()}data << float({name}{access}z);");
                        _source.WriteLine($"{GetIndent()}data << float({name}{access}w);");
                    }
                    else if (type == typeof(DynamicString))
                        _source.WriteLine($"data << WorldPackets::SizedCString::Data({name});");
                    else if (_create)
                        _source.WriteLine($"{name}{access}WriteCreate(data, owner, receiver);");
                    else
                    {
                        if (_dynamicChangesMaskTypes.Contains(type.Name))
                        {
                            _source.WriteLine($"if (no{RenameType(type.Name)}ChangesMask)");
                            _source.WriteLine($"{GetIndent()}    {name}{access}WriteCreate(data, owner, receiver);");
                            _source.WriteLine($"{GetIndent()}else");
                            _source.WriteLine($"{GetIndent()}    {name}{access}WriteUpdate(data, {(_isRoot ? "ignoreNestedChangesMask" : "ignoreChangesMask")}, owner, receiver);");

                        }
                        else
                            _source.WriteLine($"{name}{access}WriteUpdate(data, {(_isRoot ? "ignoreNestedChangesMask" : "ignoreChangesMask")}, owner, receiver);");
                    }
                    break;
                case TypeCode.Boolean:
                    _source.WriteLine($"data.WriteBit({name});");
                    break;
                case TypeCode.SByte:
                    _source.WriteLine($"data << int8({name});");
                    break;
                case TypeCode.Byte:
                    _source.WriteLine($"data << uint8({name});");
                    break;
                case TypeCode.Int16:
                    _source.WriteLine($"data << int16({name});");
                    break;
                case TypeCode.UInt16:
                    _source.WriteLine($"data << uint16({name});");
                    break;
                case TypeCode.Int32:
                    _source.WriteLine($"data << int32({name});");
                    break;
                case TypeCode.UInt32:
                    _source.WriteLine($"data << uint32({name});");
                    break;
                case TypeCode.Int64:
                    _source.WriteLine($"data << int64({name});");
                    break;
                case TypeCode.UInt64:
                    _source.WriteLine($"data << uint64({name});");
                    break;
                case TypeCode.Single:
                    _source.WriteLine($"data << float({name});");
                    break;
                case TypeCode.String:
                    _source.Write("data << WorldPackets::SizedString::Data(");
                    if (!name.Contains('[') && _writeUpdateMasks)
                        _source.Write('*');
                    _source.WriteLine($"{name});");
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(type));
            }
        }

        private Type PrepareFieldType(Type originalType)
        {
            var cppType = CppTypes.GetCppType(originalType);
            if (originalType.IsGenericType)
                return cppType.GetGenericTypeDefinition().MakeGenericType(cppType.GenericTypeArguments.Select(gp => PrepareFieldType(gp)).ToArray());

            if (cppType.Assembly == Assembly.GetExecutingAssembly() && !cppType.Assembly.IsDynamic)
                return CppTypes.CreateType("UF::" + RenameType(cppType));

            return cppType;
        }

        private void WriteFieldDeclaration(string name, UpdateField declarationType, string nameForIndex)
        {
            var fieldGeneratedType = CppTypes.GetCppType(declarationType.Type);
            string typeName;
            string line;
            if (_writeUpdateMasks)
            {
                nameForIndex = nameForIndex != null ? RenameField(nameForIndex) : name;
                var indices = _fieldBitIndex[nameForIndex];
                var bit = CppTypes.CreateConstantForTemplateParameter(indices[0]);
                var blockIndex = indices.Count > 1 ? indices[1] : -1;
                if (fieldGeneratedType.IsArray)
                {
                    if (typeof(DynamicUpdateField).IsAssignableFrom(fieldGeneratedType.GetElementType()))
                    {
                        var elementType = PrepareFieldType(fieldGeneratedType.GetElementType().GenericTypeArguments[0]);
                        typeName = TypeHandler.GetFriendlyName(elementType);
                        fieldGeneratedType = _arrayUpdateFieldType.MakeGenericType(
                            _dynamicUpdateFieldBaseType.MakeGenericType(elementType),
                            CppTypes.CreateConstantForTemplateParameter(declarationType.Size),
                            bit,
                            CppTypes.CreateConstantForTemplateParameter(blockIndex));
                    }
                    else
                    {
                        var elementType = PrepareFieldType(fieldGeneratedType.GetElementType());
                        typeName = TypeHandler.GetFriendlyName(elementType);
                        fieldGeneratedType = _arrayUpdateFieldType.MakeGenericType(elementType,
                            CppTypes.CreateConstantForTemplateParameter(declarationType.Size),
                            bit,
                            CppTypes.CreateConstantForTemplateParameter(blockIndex));
                    }
                }
                else if (typeof(DynamicUpdateField).IsAssignableFrom(declarationType.Type))
                {
                    var elementType = PrepareFieldType(fieldGeneratedType.GenericTypeArguments[0]);
                    typeName = TypeHandler.GetFriendlyName(elementType);
                    fieldGeneratedType = _dynamicUpdateFieldType.MakeGenericType(PrepareFieldType(fieldGeneratedType.GenericTypeArguments[0]),
                        CppTypes.CreateConstantForTemplateParameter(blockIndex),
                        bit);
                }
                else if (typeof(BlzOptionalField).IsAssignableFrom(declarationType.Type))
                {
                    var elementType = PrepareFieldType(fieldGeneratedType.GenericTypeArguments[0]);
                    typeName = TypeHandler.GetFriendlyName(elementType);
                    fieldGeneratedType = _optionalUpdateFieldType.MakeGenericType(elementType,
                        CppTypes.CreateConstantForTemplateParameter(blockIndex),
                        bit);
                }
                else if (typeof(VariantUpdateField).IsAssignableFrom(declarationType.Type))
                {
                    var elementTypes = fieldGeneratedType.GenericTypeArguments.Select(genericTypeArg => PrepareFieldType(genericTypeArg)).ToArray();
                    typeName = "UNSUPPORTED";
                    var genericDefinitionTypes = Enumerable.Range(1, elementTypes.Length).Select(i => "T" + i)
                        .Prepend("Bit").Prepend("BlockBit").ToArray();
                    var variantUpdateFieldType = CppTypes.CreateType("VariantUpdateField", genericDefinitionTypes);
                    fieldGeneratedType = variantUpdateFieldType.MakeGenericType(
                        elementTypes
                            .Prepend(bit)
                            .Prepend(CppTypes.CreateConstantForTemplateParameter(blockIndex)).ToArray());
                }
                else
                {
                    var elementType = PrepareFieldType(declarationType.Type);
                    typeName = TypeHandler.GetFriendlyName(elementType);
                    fieldGeneratedType = _updateFieldType.MakeGenericType(PrepareFieldType(declarationType.Type),
                        CppTypes.CreateConstantForTemplateParameter(blockIndex),
                        bit);
                }

                line = $"    {TypeHandler.GetFriendlyName(fieldGeneratedType)} {name};";
            }
            else if (fieldGeneratedType.IsArray)
            {
                typeName = TypeHandler.GetFriendlyName(fieldGeneratedType.GetElementType());
                line = $"    {typeName} {name}[{declarationType.Size}];";
            }
            else
            {
                typeName = TypeHandler.GetFriendlyName(PrepareFieldType(fieldGeneratedType));
                line = $"    {typeName} {name};";
            }

            _header.Write(line);
            if (declarationType.Comment != null)
                _header.Write($"{new string(' ', Math.Max(1, 80 - line.Length))}// {declarationType.Comment}");
            _header.WriteLine();

            if ((declarationType.CustomFlag & CustomUpdateFieldFlag.ViewerDependent) != CustomUpdateFieldFlag.None)
                _header.WriteLine($"    struct {name}Tag : ViewerDependentValueTag<{typeName}> {{}};");
        }

        public override void FinishControlBlocks(IReadOnlyList<FlowControlBlock> previousControlFlow, string tag)
        {
            _fieldWrites.Add((RenameField(tag), false, (pcf) =>
            {
                FinishControlBlocks(_source, pcf);
                return new List<FlowControlBlock>();
            }
            ));
        }

        public override void FinishBitPack(string tag)
        {
            _fieldWrites.Add((tag != null ? RenameField(tag) : "FinishBitPack", false, (pcf) =>
            {
                WriteControlBlocks(_source, pcf, pcf);
                _source.WriteLine($"{GetIndent()}data.FlushBits();");
                _indent = 1;
                return pcf;
            }));
        }

        protected override string RenameType(Type type)
        {
            return RenameType(type.Name);
        }

        private string RenameType(string name)
        {
            if (name.StartsWith("CG") && char.IsUpper(name[2]))
                name = name.Substring(2);
            if (name.EndsWith("_C"))
                name = name.Substring(0, name.Length - 2);
            if (name.StartsWith("JamMirror"))
                name = name.Substring(9);
            return name;
        }

        protected override string RenameField(string name)
        {
            name = name.Replace("m_", "");
            if (name.Length == 0)
                return name;
            return char.ToUpperInvariant(name[0]) + name.Substring(1);
        }

        private static void WriteAutogeneratedDisclaimer(TextWriter output)
        {
            output.WriteLine("// This file is automatically generated, DO NOT EDIT");
            output.WriteLine();
        }

        private static void WriteLicense(TextWriter writer)
        {
            writer.WriteLine("/*");
            writer.WriteLine(" * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information");
            writer.WriteLine(" *");
            writer.WriteLine(" * This program is free software; you can redistribute it and/or modify it");
            writer.WriteLine(" * under the terms of the GNU General Public License as published by the");
            writer.WriteLine(" * Free Software Foundation; either version 2 of the License, or (at your");
            writer.WriteLine(" * option) any later version.");
            writer.WriteLine(" *");
            writer.WriteLine(" * This program is distributed in the hope that it will be useful, but WITHOUT");
            writer.WriteLine(" * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or");
            writer.WriteLine(" * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for");
            writer.WriteLine(" * more details.");
            writer.WriteLine(" *");
            writer.WriteLine(" * You should have received a copy of the GNU General Public License along");
            writer.WriteLine(" * with this program. If not, see <http://www.gnu.org/licenses/>.");
            writer.WriteLine(" */");
            writer.WriteLine();
        }

        private static string GetClassForObjectType(ObjectType objectType)
        {
            switch (objectType)
            {
                case ObjectType.Object:
                    return "Object";
                case ObjectType.Item:
                    return "Item";
                case ObjectType.Container:
                    return "Bag";
                case ObjectType.AzeriteEmpoweredItem:
                    return "AzeriteEmpoweredItem";
                case ObjectType.AzeriteItem:
                    return "AzeriteItem";
                case ObjectType.Unit:
                    return "Unit";
                case ObjectType.Player:
                    return "Player";
                case ObjectType.ActivePlayer:
                    return "Player";
                case ObjectType.GameObject:
                    return "GameObject";
                case ObjectType.DynamicObject:
                    return "DynamicObject";
                case ObjectType.Corpse:
                    return "Corpse";
                case ObjectType.AreaTrigger:
                    return "AreaTrigger";
                case ObjectType.SceneObject:
                    return "Object";
                case ObjectType.Conversation:
                    return "Conversation";
                case ObjectType.Vendor:
                    return "Creature";
                default:
                    throw new ArgumentOutOfRangeException(nameof(objectType));
            }
        }
    }
}
